# ПРАКТИЧНА РОБОТА 2

## ЗАВДАННЯ 1

## Умова
Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

## Код до завдання
```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

void print_date_from_time_t(time_t timestamp) {
    struct tm *time_info;
    char buffer[80];

    if (timestamp < 0) {
        printf("Invalid time_t value.\n");
        return;
    }

    time_info = localtime(&timestamp);
    if (time_info == NULL) {
        printf("Error converting time_t to tm.\n");
        return;
    }

    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", time_info);
    printf("Date and time: %s\n", buffer);
}

int main() {
    time_t time32 = 2147483647;
    time_t time64 = LLONG_MAX;

    printf("Max time_t for 32-bit system: %lld\n", (long long)time32);
    print_date_from_time_t(time32);

    printf("Max time_t for 64-bit system: %lld\n", (long long)time64);

    return 0;
}
```

## Пояснення програми
Ця програма виводить максимальне значення time_t для 32-бітної та 64-бітної системи, а також переводить значення time_t
у звичайний формат дати й часу. Для цього вона використовує функцію localtime() та strftime(). Якщо значення time_t перевищує допустимий діапазон, програма виводить помилку

## Результат роботи
![image](https://github.com/user-attachments/assets/14462c2c-5d5a-461c-9590-775288c4252b)

## ЗАВДАННЯ 2

## Умова
Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму hello world, запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.
3. Тепер додайте початкове значення в оголошення масиву
(пам’ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента
BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
компілюєте для налагодження? Для максимальної оптимізації?
Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;
● сегмент BSS не зберігається у виконуваному файлі (за винятком
примітки щодо його вимог до розміру часу виконання);
● текстовий сегмент більшою мірою піддається перевіркам
оптимізації;
● на розмір файлу a.out впливає компіляція для налагодження, але не
сегменти.

## Код до завдання
```c
#include <stdio.h>

int arr1[1000];
int arr2[1000] = {0};

void func() {
    int local_arr1[1000];
    int local_arr2[1000] = {0};
    printf("Hello from function!\n");
}

int main() {
    func();
    return 0;
}
```

## Пояснення програми
Цей код містить два глобальних масиви та два локальних у функції. Масиви `arr1` та `arr2` оголошені на глобальному рівні: перший — без ініціалізації,
а другий — ініціалізований нулями. У функції `func()` є ще два масиви: `local_arr1`, який не ініціалізований, і `local_arr2`, який також ініціалізований нулями.
Програма просто викликає функцію `func()`, яка виводить повідомлення "Hello from function!". Під час компіляції кожен з цих масивів буде зберігатися в різних
сегментах пам'яті виконуваного файлу в залежності від ініціалізації та місця оголошення (глобальні чи локальні змінні).
1. Базовий Hello, world!;
o Маленький виконуваний файл.
o Сегменти .text (код), .data (ініціалізовані змінні) та .bss
(неініціалізовані змінні) містять мінімальні дані.
2. Додавання глобального масиву int arr[1000];
o Виконуваний файл став трохи більшим.
o Масив потрапив у .bss, оскільки він не ініціалізований.
3. Додавання int arr[1000] = {0};
o Збільшився сегмент .data, оскільки масив тепер ініціалізований.
o .bss залишився незмінним.
4. Додавання великих локальних масивів
o У коді видно попередження про невикористані змінні local_arr1 і
local_arr2, оскільки компілятор виявив, що вони не
використовуються.
o Локальні масиви створюються у стеку (stack) і не впливають на
розмір виконуваного файлу.
5. Компіляція з -O3
o Файл став меншим, що свідчить про оптимізацію.
o Компілятор міг видалити невикористані змінні та оптимізувати код.

Головний висновок:
1. Глобальні масиви впливають на розмір виконуваного файлу
(ініціалізовані займають .data, неініціалізовані – .bss).
2. Локальні змінні не впливають на розмір виконуваного файлу,
оскільки вони зберігаються в стеку під час виконання.
3. Оптимізація з -O3 значно зменшує розмір програми шляхом
видалення невикористаних змінних і покращення коду.

## Результат роботи
![image](https://github.com/user-attachments/assets/3b1cf4f5-6888-4bc4-b74a-902d88e9a5ca)

## ЗАВДАННЯ 3

## Умова
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
#include stdio.h;
int main() {
int i;
printf("The stack top is near %p\n", &i);
return 0;
}
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

Примітка: стек може розташовуватися за різними адресами на різних
архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на
більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями
адрес.

## Код до завдання
```c
#include <stdio.h>

void increase_stack_size() {
    int large_array[10000];
    printf("Адреса великого масиву: %p\n", (void*)large_array);
}

int main() {
    int i;
    printf("Вершина стека знаходиться близько до %p\n", (void*)&i);

    int global_var = 10;
    static int static_var = 20;

    printf("Адреса global_var (сегмент даних): %p\n", (void*)&global_var);
    printf("Адреса static_var (сегмент даних): %p\n", (void*)&static_var);
    printf("Адреса функції main (сегмент тексту): %p\n", (void*)&main);

    increase_stack_size();

    return 0;
}
```

## Пояснення програми
Цей код дозволяє визначити розташування різних сегментів пам'яті: стек, дані та текст. Виведення адреси локальної змінної `i`
показує поточну вершину стека, а адреси глобальної та статичної змінних вказують на сегмент даних. Адреса функції `main` демонструє
розташування коду програми в сегменті тексту. Виклик функції `increase_stack_size` з великим масивом змінює розмір стека, і нова адреса
вершини стека підтверджує, як стек зростає вниз по пам'яті.

## Результат роботи
![image](https://github.com/user-attachments/assets/bac3d75b-9cdd-4c78-a217-367ef0c4e4b8)

## ЗАВДАННЯ 4

## Умова
Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви можете:

● Автоматично за допомогою утиліти gstack.

● Вручну за допомогою налагоджувача GDB.

Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання (Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути pstack). Якщо gstack не працює, використовуйте другий метод – через GDB, як показано нижче. Спочатку подивіться на стек за допомогою gstack(1). Нижче наведений приклад стека bash (аргументом команди є PID процесу): $ gstack 14654 #0 0x00007f359ec7ee7a in waitpid () from /lib64/libc.so.6 #1 0x000056474b4b41d9 in waitchild.isra () #2 0x000056474b4b595d in wait_for () #3 0x000056474b4a5033 in execute_command_internal () #4 0x000056474b4a5c22 in execute_command () #5 0x000056474b48f252 in reader_loop () #6 0x000056474b48dd32 in main () $ Розбір стека: ● Номер кадру стека відображається ліворуч перед символом #.

● Кадр #0 – це найнижчий кадр. Читайте стек знизу вверх (тобто від main() – кадр #6 – до waitpid() – кадр #0).

● Якщо процес багатопотоковий, gstack покаже стек кожного потоку окремо.
Аналіз стека в режимі користувача через GDB

Щоб переглянути стек процесу вручну, використовуйте GDB, приєднавшись до процесу. Нижче наведена невелика тестова програма на C, що виконує кілька вкладених викликів функцій. Граф викликів виглядає так:

main() --&gt; foo() --&gt; bar() --&gt; bar_is_now_closed() --&gt; pause()
Системний виклик pause() – це приклад блокуючого виклику. Він переводить викликаючий процес у сплячий режим, очікуючи (або блокуючи) сигнал. У цьому випадку процес блокується, поки не отримає будь-який сигнал.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

#define MSG &quot;In function %20s; &amp;localvar = %p\n&quot;

static void bar_is_now_closed(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    printf("\n Now blocking on pause()...\n");

    pause();
}

static void bar(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    bar_is_now_closed();
}

static void foo(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    bar();
}

int main(int argc, char **argv) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    foo();
    exit(EXIT_SUCCESS);
}
Тепер відкрийте GDB

У ньому підключіться (attach) до процесу (в наведеному прикладі PID = 24957) і дослідіть стек за допомогою команди backtrace (bt):

$ gdb --quiet (gdb) attach 24957 Attaching to process 24957 Reading symbols from <...>/hspl/unit2/stacker...done. Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.26.so.debug...done. done. Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols ... (gdb) bt ...

Примітка: В Ubuntu, через питання безпеки, GDB не дозволяє підключатися до довільного процесу. Це можна обійти, запустивши GDB від імені користувача root.

Аналіз того ж процесу через gstack

$ gstack 24957 ...

gstack — це, по суті, оболонковий скрипт (wrapper shell script), який неінтерактивно викликає GDB і запускає команду backtrace, яку ви щойно використали. Завдання: Ознайомтеся з виводом gstack і порівняйте його з GDB.

## Код до завдання
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define MSG "In function %20s; &localvar = %p\n"

static void bar_is_now_closed(void) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    pause();
}

static void bar(void) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    bar_is_now_closed();
}

static void foo(void) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    bar();
}

int main(int argc, char **argv) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    foo();
    exit(EXIT_SUCCESS);
    return 0;
}
```

## Пояснення програми
Задача полягає в тому, щоб подивитись, що відбувається в програмі на момент її виконання, розглядаючи стек викликів. У коді програма викликає функції одна за одною, і в кінці зупиняється на виклику pause(), чекаючи сигналу.
Кожна функція виводить адресу своєї локальної змінної, щоб показати, де саме в пам'яті вона знаходиться. Це допомагає зрозуміти, як програма переходить від однієї функції до іншої.
Для того, щоб подивитись, що відбувається з програмою, можна підключитись до її процесу за допомогою GDB або gstack. Це дасть змогу побачити стек викликів і зрозуміти, на якій функції зупинилась програма.

## Результат роботи
![image](https://github.com/user-attachments/assets/8fdbb667-b765-4bf5-b4f5-6d49bebe69ad)

## ЗАВДАННЯ 5

## Умова
Відомо, що при виклику процедур і поверненні з них процесор
використовує стек.Чи можна в такій схемі обійтися без лічильника команд
(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою
відповідь та наведіть приклади.

## Код до завдання
```c
#include <stdio.h>
#include <setjmp.h>

jmp_buf buf;

void func() {
    printf("Виконання функції func()\n");
    longjmp(buf, 1);
}

int main() {
    if (setjmp(buf) == 0) {
        printf("Вхід у main()\n");
        func();
    } else {
        printf("Повернення в main() без використання IP!\n");
    }
    return 0;
}
```

## Пояснення програми
У моєму коді використовується функція setjmp, яка зберігає поточний стан
програми, включаючи адресу, на яку потрібно повернутися пізніше. Це
дозволяє уникнути використання лічильника команд (IP) безпосередньо,
оскільки після виклику longjmp програма "переходить" до точки, де був
викликаний setjmp. Це означає, що для повернення програма використовує
вершину стека, зберігаючи всю необхідну інформацію про контекст виконання.
Таким чином, замість того, щоб явно змінювати IP, програма отримує
інформацію з буфера, який зберігається на стосі. В результаті, моя програма не
потребує прямого використання лічильника команд для коректного повернення.

## Результат роботи
![image](https://github.com/user-attachments/assets/f23c95f2-f73a-446c-aaf7-237beee411b6)

## ЗАВДАННЯ 6 (ВАРІАНТ 13)

## Умова
Дослідіть вплив оптимізації -Os на розмір сегментів.

## Код до завдання
```c
/*#include <stdio.h>

int global_var = 5;

void foo() {
    int local_var = 10;
    printf("Global var: %d, Local var: %d\n", global_var, local_var);
}

int main() {
    foo();
    return 0;
}

*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char global_arr[10000];
static int static_var = 42;
int uninitialized_var;

void test_function() {
    char local_arr[5000];
    memset(local_arr, 1, sizeof(local_arr));
    printf("Function executed\n");
}

int main() {
    printf("Text segment function: %p\n", &test_function);
    printf("Data segment variable: %p\n", &static_var);
    printf("BSS segment variable: %p\n", &uninitialized_var);
    printf("Heap allocated: %p\n", malloc(1000));
    test_function();
    return 0;
}
```

## Пояснення програми
Як бачимо, після застосування флагу -Os, розмір сегменту text (який містить
код) зменшився, а також зменшився розмір сегменту data (змінні), оскільки
оптимізація спрощує деякі конструкції і видаляє непотрібний код.
Оптимізація з флагом -Os сприяє зменшенню розміру сегментів програми,
зокрема текстового сегменту та сегменту даних, шляхом використання менш
ресурсоємних інструкцій, видалення мертвого коду та інших технік,
спрямованих на економію пам&#39;яті. Це особливо корисно для обмежених в
ресурсах середовищ, таких як вбудовані системи, де кожен байт пам&#39;яті має
значення.
Виконання такої оптимізації може вплинути на швидкість роботи програми,
оскільки деякі з оптимізацій можуть знижувати ефективність коду (наприклад,
через використання менш оптимальних інструкцій), але здебільшого це
мінімально помітно в реальному використанні, особливо для програм з малими
вимогами до швидкодії.

## Результат роботи
![image](https://github.com/user-attachments/assets/7ad4b219-0a76-4fb2-8c42-79722961574f)

